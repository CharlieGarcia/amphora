'use strict';

/**
 * This file is used for resolving the url to publish
 * an page as well as storing the URL history for
 * the page.
 */
var log = require('./logger').setup({
  file: __filename,
  action: 'publish'
});
const _ = require('lodash'),
  bluebird = require('bluebird'),
  { parse } = require('url'),
  db = require('./db'),
  buf = require('./buffer'),
  chain = require('chain-of-promises'),
  siteService = require('./sites'),
  references = require('./references');

/**
 * grab any old urls from the published page (if it exist) and save them in the current page
 * note: we're modifying data in place (but returning the url history)
 * @param {String} url (new url generated by the publishing service)
 * @param {String} uri
 * @param {Object} data
 * @returns {Promise}
 */
function storeUrlHistory(url, uri, data) {
  // get the published page (if it exists) and update the urlHistory array
  return db.get(uri)
    .then(JSON.parse)
    .catch(function () {
      // if this is the first time we're publishing, db.get() won't find
      // the published page data. thus, return empty object so we can add the urlHistory
      return {};
    })
    .then(function (publishedPageData) {
      data.urlHistory = publishedPageData.urlHistory || [];

      console.log('!!!!!', data.urlHistory, url, uri);
      if (_.last(data.urlHistory) !== url) {
        // only add urls if they've changed
        // note: this checks the last url, so you can revert urls you don't like, e.g.
        // originally published with: domain.com/foo.html
        // re-published with: domain.com/bar.html
        // reverted (re-published again) with: domain.com/foo.html
        data.urlHistory.push(url);
      }
      return data.urlHistory; // always return url history
    });
}

/**
 * Given page data, locals and a generated url make
 * sure the new url is added to all the appropriate
 * places for saving published data
 *
 * @param {String} generatedUrl
 * @param {Object} page
 * @param {Object} locals
 * @returns {Promise}
 */
function updatePageAndLocalsWithUrl(generatedUrl, page, locals) {
  // add url to published page
  if (!page.url) {
    page.url = generatedUrl;
  }

  // if they didn't provide one already, fill it in.
  // note: locals.canonicalUrl is deprecated. if you're writing a component that
  // needs the generated url, use locals.url instead
  if (!locals.canonicalUrl) {
    locals.canonicalUrl = generatedUrl;
  }

  // for all the components that will be published to use
  // TODO: Something is setting `locals.url` to the page URI, this needs to be
  // investigated before we can rely on `locals.url`. Until then use `locals.canonicalUrl`
  if (!locals.url) {
    locals.url = generatedUrl;
  }

  return Promise.resolve(generatedUrl);
}

/**
 * add a 301 redirect to the previous uri
 * note: we only need to add it to the previous one, because ones before will point
 * to it, e.g. /one.html → /two.html → /three.html
 * multiple 301s on the same server have no performance penalties
 * @param {array} urlHistory
 * @param {string} uri
 * @returns {Promise|undefined}
 */
function addRedirects(urlHistory, uri) {
  if (urlHistory.length > 1) {
    // there are old urls! redirect the previous url to latest url
    let prevUrl = parse(urlHistory[urlHistory.length - 2]),
      prevUri = `${prevUrl.hostname}${prevUrl.pathname}`,
      newUrl = parse(_.last(urlHistory)),
      newUri = `${newUrl.hostname}${newUrl.pathname}`,
      prefix = references.getPagePrefix(uri);

    // update the previous uri to point to the latest uri
    return db.put(`${prefix}/uris/${buf.encode(prevUri)}`, `${prefix}/uris/${buf.encode(newUri)}`);
  }
}

/**
 * Return the url for a page based on own url or throw.
 * @param {Object} pageData
 * @returns {Promise}
 */
function getPassthroughPageUrl(pageData) {
  // if we're not publishing an article page but there IS already a url, use it
  // note: this only works because we're bootstrapping non-article pages
  // todo: generate urls for non-article pages by using a custom url override
  if (!pageData.url) {
    return Promise.reject(new Error('Non-article pages need a url already defined!'));
  }
  return Promise.resolve(pageData.url);
}


/**
 * Always do these actins when publishing a page
 *
 * @param {String} url
 * @param {String} uri
 * @param {Object} data
 * @param {Object} locals
 * @param {Object} sites
 * @return {Promise}
 */
function publishPageAtUrl(url, uri, data, locals, site) {
  // So a url can still be derived from rules unique to the
  // implementation, but customUrl should override those rules
  url = data.customUrl || url;

  return updatePageAndLocalsWithUrl(url, data, locals)
    .then(url => storeUrlHistory(url, uri, data))
    .then(urlHistory => addRedirects(urlHistory, uri))
    .then(() => modifyPageData(site, data))
    .catch(e => {
      console.log(e.message);
      throw e;
    });
}

/**
 * Allow site to append data to a published page before
 * publishing. Hooks are specified in the `modifyPageData`
 * Array in the site's index.js and should be an Array of
 * synchronous or asynchronous functions
 *
 * @param  {Array}  modifyPageData
 * @param  {Object} data
 * @return {Promise}
 */
function modifyPageData({ modifyPageData }, data) {
  if (!_.isArray(modifyPageData)) {
    return bluebird.resolve(data);
  }

  return bluebird.reduce(modifyPageData, function (acc, val) {
    return bluebird.try(val.bind(null, acc))
      .catch(e => {
        log('error', `Error modifying page data on publish: ${e.message}`)
      });
  }, data);
}

function resolvePublish(uri, locals, site, pageData) {
  /**
   * The publishing chain is an array of functions which either return a function to publish a page
   * or throw an error.  This is a variant of the Chain of Responsibility pattern, which we're calling Reject Quickly/Resolve Slowly.
   * Functions should reject quickly if the data doesn't match the format they want, and afterwards resolve the generated url if the data does match.
   * The function that resolves is expected to add a `url` property to pageData and return pageData or a promise that resolves to pageData
   */
  var publishingChain = [];

  if (_.isFunction(site.resolvePublishing)) {
    // Allow a site to add or modify the publishing chain
    publishingChain = site.resolvePublishing(publishingChain, locals) || publishingChain;
  }

  if ( publishingChain.length > 0 ) {
    // Iterate over an array of publishing functions sequentially to find the first one which resolves
    return chain(publishingChain, uri, pageData, locals)
      .then(function (url) {
        return publishPageAtUrl(url, uri, pageData, locals, site);
      })
      .catch(() => pageData);
  }


  return Promise.resolve(pageData);
}

module.exports = resolvePublish;
module.exports.publishPageAtUrl = publishPageAtUrl;
